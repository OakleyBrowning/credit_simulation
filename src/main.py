# -*- coding: utf-8 -*-
"""Private Credit Portfolio Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jbfd0XD8z9KdYDMKCFkzPFrLQWSqgEul

**Libraries**
"""

!pip install numpy-financial

import numpy as np
import pandas as pd
import inspect
import numpy_financial as npf
from tqdm import tqdm
import matplotlib.pyplot as plt

"""**Portfolio distribution**"""

allocation = 25000000000

portfolio_dist = {
    "Senior Secured Loans (BB)": 0.30,
    "Middle-Market Direct Lending": 0.35,
    "Unitranche Loans": 0.10,
    "Mezzanine Debt": 0.10,
    "Distressed and Special Situations": 0.05,
    "Real Estate and Infrastructure Debt": 0.10
}

"""**Loan Parameters**"""

loan_types = {
    "Senior Secured Loans (BB)": {
        "mean_yield": 0.0631,
        "std_yield": 0.0017,
        "term_length": (3, 6),
        "repayment_structure": "amortizing",
        "interest_type": "floating",
        "default_rate": 0.0204
    },
    "Middle-Market Direct Lending": {
        "mean_yield": .07791,
        "std_yield": 0.0039,
        "term_length": (4, 8),
        "repayment_structure": "amortizing_balloon",
        "interest_type": ["fixed", "floating"],
        "default_rate": .0347
    },
    "Unitranche Loans": {
        "mean_yield": 0.0911,
        "std_yield": 0.0039,
        "term_length": (4, 6),
        "repayment_structure": "bullet",
        "interest_type": "floating",
        "default_rate": 0.0473
    },
    "Mezzanine Debt": {
        "mean_yield": 0.149959,
        "std_yield": 0.000916,
        "term_length": (7, 10),
        "repayment_structure": "bullet_with_PIK",
        "interest_type": "fixed",
        "default_rate": 0.0688
    },
    "Distressed and Special Situations": {
        "mean_yield": 0.16694,
        "std_yield": 0.0127,
        "term_length": (2, 5),
        "repayment_structure": ["PIK", "bullet"],
        "interest_type": "fixed",
        "default_rate": 0.098
    },
    "Real Estate and Infrastructure Debt": {
        "mean_yield": 0.07615,
        "std_yield": 0.0117,
        "term_length": (5, 11),
        "repayment_structure": "interest_with_balloon",
        "interest_type": "floating",
        "default_rate": 0.0178
    }
}

"""**Originate loans**"""

def initialize_loans(allocation, portfolio_dist, loan_types, max_percent=0.006, max_quarters=20):
    """
    Creates a comprehensive list of all loans the portfolio will originate,
    ensuring loans are evenly distributed across first 5 years.

    Parameters:
    - allocation: Total capital to be allocated.
    - portfolio_dist: Distribution of capital across loan types (dictionary).
    - loan_types: Characteristics of each loan type (dictionary).
    - max_percent: Maximum percentage of total allocation for a single loan.
    - max_quarters: Number of quarters over which loans can originate.

    Returns:
    - loans_df: A DataFrame of all loans with their starting parameters.
    """
    loans = []
    remaining_allocation = allocation
    max_loan_size = allocation * max_percent
    quarter_allocation = allocation / max_quarters

    for quarter in range(1, max_quarters + 1):
        # Cap allocation per type for this quarter
        quarter_remaining = quarter_allocation
        for loan_type, dist_percent in portfolio_dist.items():
            allocation_per_type = allocation * dist_percent / max_quarters
            if allocation_per_type <= 0:
                continue

            while allocation_per_type > 0 and quarter_remaining > 0 and remaining_allocation > 0:
                loan_size = np.random.uniform(0.003, 0.006) * allocation  # Between 0.3%-0.6% of total allocation
                loan_size = min(loan_size, max_loan_size, allocation_per_type, quarter_remaining, remaining_allocation)

                if loan_size <= 0:
                    break  # Stop if allocation is exhausted

                # Generate loan characteristics
                params = loan_types[loan_type]

                # Randomly assign interest type for direct lending
                selected_interest_type = (
                    np.random.choice(params["interest_type"])
                    if loan_type == "Middle-Market Direct Lending"
                    else params["interest_type"]
                )

                # Randomly assign repayment type for distressed
                selected_repayment_type = (
                    np.random.choice(params["repayment_structure"])
                    if loan_type == "Distressed and Special Situations"
                    else params["repayment_structure"]
                )

                # Initial interest rate
                interest_rate = np.random.normal(params["mean_yield"], params["std_yield"])

                # Determine default rate with variability
                default_rate = max(0,min(1,
                        np.random.normal(
                            params["default_rate"],
                            0.1 * params["default_rate"]
                        )
                    )
                )

                loan_data = {
                    "loan_id": len(loans) + 1,
                    "loan_type": loan_type,
                    "origination_period": quarter,
                    "principal": loan_size,
                    "interest_rate": interest_rate,
                    "repayment_structure": selected_repayment_type,
                    "interest_type": selected_interest_type,
                    "default_rate": default_rate,
                    "term_length_quarters": np.random.randint(params["term_length"][0], params["term_length"][1]) * 4,
                    "portfolio_allocation_percent": (loan_size / allocation) * 100
                }
                loans.append(loan_data)

                # Deduct from allocations
                allocation_per_type -= loan_size
                quarter_remaining -= loan_size
                remaining_allocation -= loan_size

    return pd.DataFrame(loans)

"""**Functions to simulate the repayment schedules for each of the six distinct loan types**

***Senior Secured Loans (Large Corporate)***
"""

def senior_schedule(
    loan_id,
    principal,
    initial_yield,
    mean_yield,
    std_yield,
    origination_quarter,
    term_quarters,
    default_rate,
    portfolio_allocation_percent,
    ltv_mean=0.6,
    ltv_std_dev=0.05,
    recovery_haircut=0.2,
    enforcement_cost_percent=0.05,
    collateral_depreciation_rate=0.01
):
    """
    Simulates the quarterly repayment schedule for a single Senior Secured Loan with floating interest rates,
    including default and recovery scenarios.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - initial_yield: Initial fixed or floating yield for the first period.
    - mean_yield: Mean annualized yield for floating interest rates.
    - std_yield: Standard deviation of the yield for floating interest rates.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - ltv_mean: Mean LTV for collateral value.
    - ltv_std_dev: Standard deviation of LTV for collateral value.
    - recovery_haircut: Haircut on market value of collateral recovered from default.
    - enforcement_cost_percent: Cost of enforcement of collateral recovery.
    - collateral_depreciation_rate: Quarterly rate of collateral depreciation.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    schedule = []
    remaining_principal = principal
    quarterly_default = default_rate / 4.0

    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_profit = 0

    repayment_start = origination_quarter + 1
    repayment_end = origination_quarter + term_quarters

    # Initialize collateral value based on LTV and loan principal
    ltv = np.random.normal(ltv_mean, ltv_std_dev)
    collateral_value = principal / ltv

    for q in range(origination_quarter, repayment_end + 1):
        remaining_term = repayment_end - q + 1
        status = "Active"

        # Depreciate collateral value each quarter
        collateral_value = remaining_principal / ltv
        collateral_value *= (1 - collateral_depreciation_rate)
        net_collateral_value = collateral_value * (1 - recovery_haircut) - (enforcement_cost_percent * collateral_value)

        if q == origination_quarter:
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "senior secured loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": term_quarters,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            continue

        # Get current quarterly interest rate
        current_annual_rate = np.random.normal(mean_yield, std_yield)
        quarterly_interest = current_annual_rate / 4

        # Calculate payment structure
        if remaining_term > 1:
            fixed_payment = (quarterly_interest * remaining_principal) / \
                            (1 - (1 + quarterly_interest) ** -remaining_term)
            interest_payment = remaining_principal * quarterly_interest
            principal_payment = fixed_payment - interest_payment
        else:
            # Final payment to clear balance
            interest_payment = remaining_principal * quarterly_interest
            principal_payment = remaining_principal
            fixed_payment = interest_payment + principal_payment
            remaining_principal = 0

        # Default occurs
        if np.random.rand() < quarterly_default:
            status = "Defaulted"
            # Recovery based on net collateral value and remaining principal
            recovery_amount = min(remaining_principal, net_collateral_value)
            default_loss = remaining_principal - recovery_amount

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "senior secured loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": current_annual_rate,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": default_loss,
                "recovery_amount": recovery_amount,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            break

        # Update loan balances and cumulative metrics
        remaining_principal -= principal_payment
        cumulative_interest += interest_payment
        cumulative_principal += principal_payment
        cumulative_profit = (cumulative_interest + cumulative_principal) - principal

        if remaining_principal <= 0:
            status = "Paid Off"

        schedule.append({
            "loan_id": loan_id,
            "loan_type": "senior secured loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(remaining_term - 1, 0),
            "annual_interest_rate": current_annual_rate,
            "interest_payment": interest_payment,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": max(remaining_principal, 0),
            "collateral_value": net_collateral_value,
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent,
        })

        if remaining_principal <= 0:
            break

    return pd.DataFrame(schedule)

"""***Direct Lending Loans***"""

def direct_lending_schedule(
    loan_id,
    principal,
    initial_yield,
    mean_yield,
    std_yield,
    origination_quarter,
    term_quarters,
    default_rate,
    portfolio_allocation_percent,
    interest_type,
    balloon_percent=0.4,
    ltv_mean=0.7,
    ltv_std_dev=0.1,
    recovery_haircut=0.3,
    enforcement_cost_percent=0.1,
    collateral_depreciation_rate=0.02,
):
    """
    Simulates the quarterly repayment schedule for a single Middle-Market Direct Lending loan
    with an amortizing-balloon structure.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - initial_yield: Initial fixed or floating yield for the first period.
    - mean_yield: Mean annualized yield for floating interest rates.
    - std_yield: Standard deviation of the yield for floating interest rates.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - interest_type: Type of interest ('fixed' or 'floating').
    - balloon_percent: Portion of the principal deferred to the final payment.
    - ltv_mean: Mean LTV for collateral value.
    - ltv_std_dev: Standard deviation of LTV for collateral value.
    - recovery_haircut: Haircut on market value of collateral recovered from default.
    - enforcement_cost_percent: Cost of enforcement of collateral recovery.
    - collateral_depreciation_rate: Quarterly rate of collateral depreciation.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    schedule = []
    remaining_principal = principal
    quarterly_default = default_rate / 4.0

    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_profit = 0

    repayment_end = origination_quarter + term_quarters

    # Initialize collateral value based on LTV and loan principal
    ltv = np.random.normal(ltv_mean, ltv_std_dev)
    collateral_value = principal / ltv

    for q in range(origination_quarter, repayment_end + 1):
        remaining_term = repayment_end - q + 1
        status = "Active"

        # Depreciate collateral value each quarter
        collateral_value = remaining_principal / ltv
        collateral_value *= (1 - collateral_depreciation_rate)
        net_collateral_value = collateral_value * (1 - recovery_haircut) - (enforcement_cost_percent * collateral_value)

        if q == origination_quarter:
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "middle-market direct lending loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": term_quarters,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            continue

        # Determine the current interest rate
        if interest_type == "floating":
            current_annual_rate = np.random.normal(mean_yield, std_yield)
        else:
            current_annual_rate = initial_yield
        quarterly_rate = current_annual_rate / 4

        # Default logic
        if np.random.rand() < quarterly_default:
            # Calculate recovery and loss
            recovery_amount = min(remaining_principal, net_collateral_value)
            default_loss = remaining_principal - recovery_amount
            status = "Defaulted"

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "middle-market direct lending loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": current_annual_rate,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": default_loss,
                "recovery_amount": recovery_amount,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            break

        # Regular payment calculations
        if remaining_term > 1:
            fixed_payment = (quarterly_rate * (remaining_principal * (1 - balloon_percent))) / \
                            (1 - (1 + quarterly_rate) ** -remaining_term)
            interest_payment = remaining_principal * quarterly_rate

            if fixed_payment < interest_payment:
                principal_payment = 0
            else:
                principal_payment = fixed_payment - interest_payment
        else:
            # Balloon payment in the last quarter
            interest_payment = remaining_principal * quarterly_rate
            principal_payment = remaining_principal
            remaining_principal = 0

        remaining_principal = max(remaining_principal - principal_payment, 0)
        cumulative_interest += interest_payment
        cumulative_principal += principal_payment
        cumulative_profit = (cumulative_interest + cumulative_principal) - principal
        status = "Active" if remaining_principal > 0 else "Paid Off"

        schedule.append({
            "loan_id": loan_id,
            "loan_type": "middle-market direct lending loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(remaining_term - 1, 0),
            "annual_interest_rate": current_annual_rate,
            "interest_payment": interest_payment,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": remaining_principal,
            "collateral_value": net_collateral_value,
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent,
        })

        if remaining_principal <= 0:
            break

    return pd.DataFrame(schedule)

"""***Unitranche Loans***"""

def unitranche_schedule(
    loan_id,
    principal,
    origination_quarter,
    term_quarters,
    default_rate,
    mean_yield,
    std_yield,
    initial_yield,
    portfolio_allocation_percent,
    ltv_mean=0.7,
    ltv_std_dev=0.05,
    recovery_haircut=0.25,
    enforcement_cost_percent=0.1,
    collateral_depreciation_rate=0.02,
    first_out_percent=0.7
):
    """
    Simulates the quarterly repayment schedule for a single Unitranche Loan
    with a bullet repayment structure and floating interest rates.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - mean_yield: Mean annualized yield for floating interest rates.
    - std_yield: Standard deviation of the yield for floating interest rates.
    - initial_yield: Initial fixed or floating yield for the first period.
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - ltv_mean: Mean Loan-to-Value for collateral value.
    - ltv_std_dev: Standard deviation of LTV.
    - recovery_haircut: Haircut on market value of collateral recovered from default.
    - enforcement_cost_percent: Cost of enforcement of collateral recovery.
    - collateral_depreciation_rate: Quarterly depreciation rate of collateral value.
    - first_out_percent: Percentage of loan allocated to first-out lenders.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    schedule = []
    remaining_principal = principal
    quarterly_default = default_rate / 4.0

    cumulative_interest = 0
    cumulative_principal = 0

    repayment_end = origination_quarter + term_quarters

    # Initialize collateral value based on LTV and loan principal
    ltv = np.random.normal(ltv_mean, ltv_std_dev)
    collateral_value = principal / ltv

    for q in range(origination_quarter, repayment_end + 1):
        remaining_term = repayment_end - q + 1
        status = "Active"

        # Depreciate collateral value each quarter
        collateral_value *= (1 - collateral_depreciation_rate)
        net_collateral_value = collateral_value * (1 - recovery_haircut) - (collateral_value * enforcement_cost_percent)

        # Update interest rate
        current_annual_rate = np.random.normal(mean_yield, std_yield)
        quarterly_rate = current_annual_rate / 4

        if q == origination_quarter:
            # Record origination details
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "unitranche loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": term_quarters,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            continue

        # Default logic
        if np.random.rand() < quarterly_default:
            # Calculate first-out and last-out recovery and loss
            first_out_principal = principal * first_out_percent
            last_out_principal = principal * (1 - first_out_percent)

            first_out_recovery = min(first_out_principal, net_collateral_value * first_out_percent)
            last_out_recovery = max(0, net_collateral_value - first_out_recovery)

            first_out_loss = first_out_principal - first_out_recovery
            last_out_loss = last_out_principal - last_out_recovery

            default_loss = first_out_loss + last_out_loss
            status = "Defaulted"

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "unitranche loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": current_annual_rate,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": net_collateral_value,
                "default_loss": default_loss,
                "recovery_amount": net_collateral_value,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            break

        # Regular payment calculations
        if q == repayment_end:
            interest_payment = remaining_principal * quarterly_rate
            principal_payment = remaining_principal
            remaining_principal = 0
            status = "Paid Off"
        else:
            interest_payment = remaining_principal * quarterly_rate
            principal_payment = 0

        cumulative_interest += interest_payment
        cumulative_principal += principal_payment

        # Append to schedule
        schedule.append({
            "loan_id": loan_id,
            "loan_type": "unitranche loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(remaining_term - 1, 0),
            "annual_interest_rate": current_annual_rate,
            "interest_payment": interest_payment,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": remaining_principal,
            "collateral_value": net_collateral_value,
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent,
        })

        if remaining_principal <= 0:
            break

    return pd.DataFrame(schedule)

"""***Mezzanine Debt***"""

def mezzanine_schedule(
    loan_id,
    principal,
    initial_yield,
    origination_quarter,
    term_quarters,
    default_rate,
    portfolio_allocation_percent,
    cash_to_pik_ratio=0.6,
    recovery_rate=0.2
):
    """
    Simulates the quarterly repayment schedule for a single Mezzanine Loan
    with a bullet repayment structure.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - initial_yield: Fixed annual interest rate for the loan.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - cash_to_pik_ratio: Ratio of cash to PIK interest (default is 60% cash, 40% PIK).
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - recovery_rate: Fraction of remaining principal recovered in case of default.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    schedule = []
    remaining_principal = principal
    quarterly_default = default_rate / 4.0
    quarterly_rate = initial_yield / 4

    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_profit = 0

    repayment_start = origination_quarter + 1
    repayment_end = origination_quarter + term_quarters

    for q in range(origination_quarter, repayment_end + 1):
        quarters_remaining = repayment_end - q + 1
        status = "Active"

        if q == origination_quarter:
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "mezzanine loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": term_quarters,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            continue

        # Simulate default
        if np.random.rand() < quarterly_default:
            # Calculate recovery and loss
            recovery_amount = remaining_principal * recovery_rate
            default_loss = remaining_principal - recovery_amount
            status = "Defaulted"

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "mezzanine loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "default_loss": default_loss,
                "recovery_amount": recovery_amount,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            break

        total_interest = remaining_principal * quarterly_rate

        # Split interest into cash and PIK portions
        cash_interest = total_interest * cash_to_pik_ratio
        pik_interest = total_interest - cash_interest

        remaining_principal += pik_interest
        cumulative_interest += cash_interest

        # Handle final bullet payment in the last quarter
        if q == repayment_end:
            principal_payment = remaining_principal
            remaining_principal = 0
            status = "Paid Off"
        else:
            principal_payment = 0

        cumulative_principal += principal_payment
        cumulative_profit = (cumulative_interest + cumulative_principal) - principal

        schedule.append({
            "loan_id": loan_id,
            "loan_type": "mezzanine loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(quarters_remaining - 1, 0),
            "annual_interest_rate": initial_yield,
            "interest_payment": cash_interest,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": max(remaining_principal, 0),
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent,
        })

        # Stop if the loan is fully repaid
        if remaining_principal <= 0:
            break

    return pd.DataFrame(schedule)

"""***Distressed and Special Situations***"""

def distressed_schedule(
    loan_id,
    principal,
    initial_yield,
    origination_quarter,
    term_quarters,
    default_rate,
    repayment_type,
    portfolio_allocation_percent,
    ltv=0.7,
    recovery_haircut=0.3,
    enforcement_cost_percent=0.1,
    unsecured_recovery_rate=0.1
):
    """
    Simulates the quarterly repayment schedule for a single Distressed Loan
    with a bullet repayment structure.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - initial_yield: Fixed annual interest rate for the loan.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - repayment_type: Required. Either "PIK" or "bullet" to define the repayment structure.
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - ltv: Loan-to-value ratio for collateral.
    - recovery_haircut: Haircut applied to the collateral value during recovery.
    - enforcement_cost_percent: Percentage of collateral value lost to enforcement costs.
    - unsecured_recovery_rate: Recovery rate on unsecured portion of the loan.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    # Define deferred and ramp-up periods for bullet loans
    deferred_quarters = 4
    ramp_up_quarters = 8

    schedule = []
    remaining_principal = principal
    accrued_interest_bullet = 0
    quarterly_default = default_rate / 4.0
    quarterly_rate = initial_yield / 4

    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_profit = 0

    repayment_start = origination_quarter + 1
    repayment_end = origination_quarter + term_quarters

    for q in range(origination_quarter, repayment_end + 1):
        quarters_remaining = repayment_end - q + 1
        status = "Active"

        # Initialize interest and principal payments for the period
        interest_payment = 0
        principal_payment = 0

        if q == origination_quarter:
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "distressed loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": term_quarters,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": 0,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent
            })
            continue

        # Simulate default
        if np.random.rand() < quarterly_default:
            # Calculate recovery and loss
            collateral_value = remaining_principal / ltv
            depreciated_collateral_value = collateral_value * (1 - recovery_haircut) - (
                collateral_value * enforcement_cost_percent
            )

            secured_portion = remaining_principal * 0.7
            unsecured_portion = remaining_principal * 0.3

            secured_recovery = min(secured_portion, depreciated_collateral_value)
            unsecured_recovery = unsecured_portion * unsecured_recovery_rate

            total_recovery = secured_recovery + unsecured_recovery
            default_loss = remaining_principal - total_recovery
            status = "Defaulted"

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "distressed loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": remaining_principal,
                "collateral_value": depreciated_collateral_value,
                "default_loss": default_loss,
                "recovery_amount": total_recovery,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent
            })
            break

        interest = remaining_principal * quarterly_rate

        if repayment_type == "PIK":
            # Add interest to principal for PIK loans
            remaining_principal += interest
            interest_payment = 0

        elif repayment_type == "bullet":
            # Deferred period: No payments, accrue interest
            if q <= origination_quarter + deferred_quarters:
                accrued_interest_bullet += interest
                interest_payment = 0

            # Ramp-up period: Gradual increase in payments
            elif q <= origination_quarter + deferred_quarters + ramp_up_quarters:
                ramp_up_progress = (q - (origination_quarter + deferred_quarters)) / ramp_up_quarters
                interest_payment = interest * ramp_up_progress
                accrued_interest_bullet += (interest - interest_payment)

            # Full payments after ramp-up period
            else:
                interest_payment = interest

        # Final repayment in the last quarter
        if q == repayment_end:
            interest_payment += accrued_interest_bullet
            principal_payment = remaining_principal
            remaining_principal = 0
            accrued_interest_bullet = 0
            status = "Paid Off"

        cumulative_interest += interest_payment
        cumulative_principal += principal_payment
        cumulative_profit = (cumulative_interest + cumulative_principal) - principal

        schedule.append({
            "loan_id": loan_id,
            "loan_type": "distressed loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(quarters_remaining - 1, 0),
            "annual_interest_rate": initial_yield,
            "interest_payment": interest_payment,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": max(remaining_principal, 0),
            "collateral_value": 0,
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent
        })

    return pd.DataFrame(schedule)

"""***Real Estate & Infrastructure***"""

def real_estate_schedule(
    loan_id,
    principal,
    initial_yield,
    mean_yield,
    std_yield,
    origination_quarter,
    term_quarters,
    default_rate,
    portfolio_allocation_percent,
    balloon_rate=0.4,
    ltv_mean=0.65,
    ltv_std_dev=0.05,
    recovery_haircut=0.25,
    enforcement_cost_percent=0.1,
    collateral_depreciation_rate=0.03,
):
    """
    Simulates the quarterly repayment schedule for a Real Estate Loan
    with interest + amortizing balloon repayment structure and floating interest rates.

    Parameters:
    - loan_id: Loan ID.
    - principal: Initial loan amount.
    - initial_yield: Fixed annual interest rate for the first quarter.
    - mean_yield: Mean annualized yield for floating interest rates.
    - std_yield: Standard deviation of the annualized yield.
    - origination_quarter: The quarter in which the loan originates.
    - term_quarters: Loan term in quarters.
    - default_rate: Annual probability of default.
    - portfolio_allocation_percent: Allocation percentage of the portfolio.
    - ltv_mean: Mean LTV for property value.
    - ltv_std_dev: Standard deviation for LTV.
    - recovery_haircut: Haircut for collateral value during recovery.
    - enforcement_cost_percent: Enforcement costs as a percentage of property value.
    - collateral_depreciation_rate: Quarterly depreciation of collateral value.

    Returns:
    - repayment_schedule: A DataFrame representing the repayment schedule.
    """
    schedule = []
    remaining_principal = principal
    quarterly_default = default_rate / 4.0
    balloon_principal = principal * balloon_rate
    amortizing_principal = principal * (1 - balloon_rate)
    quarterly_principal_payment = amortizing_principal / term_quarters

    ltv = np.random.normal(ltv_mean, ltv_std_dev)
    property_value = principal / ltv

    current_quarterly_rate = initial_yield / 4

    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_profit = 0

    repayment_end = origination_quarter + term_quarters

    for q in range(origination_quarter, repayment_end + 1):
        quarters_remaining = repayment_end - q + 1
        status = "Active"

        # Depreciate property value quarterly
        property_value *= (1 - collateral_depreciation_rate)
        net_collateral_value = property_value * (1 - recovery_haircut) - (property_value * enforcement_cost_percent)

        if q == origination_quarter:
            schedule.append({
                "loan_id": loan_id,
                "loan_type": "real estate loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": max(quarters_remaining - 1, 0),
                "annual_interest_rate": initial_yield,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": max(remaining_principal, 0),
                "collateral_value": property_value,
                "default_loss": 0,
                "recovery_amount": 0,
                "cumulative_interest_payments": 0,
                "cumulative_principal_payments": 0,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            continue

        # Simulate default
        if np.random.rand() < quarterly_default:
            recovery_amount = min(remaining_principal, net_collateral_value)
            default_loss = remaining_principal - recovery_amount
            status = "Defaulted"

            schedule.append({
                "loan_id": loan_id,
                "loan_type": "real estate loan",
                "status": status,
                "period_originated": origination_quarter,
                "current_period": q,
                "periods_remaining": 0,
                "annual_interest_rate": current_quarterly_rate * 4,
                "interest_payment": 0,
                "starting_principal": principal,
                "principal_payment": 0,
                "remaining_principal": max(remaining_principal, 0),
                "collateral_value": property_value,
                "default_loss": default_loss,
                "recovery_amount": recovery_amount,
                "cumulative_interest_payments": cumulative_interest,
                "cumulative_principal_payments": cumulative_principal,
                "portfolio_allocation_percent": portfolio_allocation_percent,
            })
            break

        interest_payment = remaining_principal * current_quarterly_rate

        # Handle final balloon payment in the last quarter
        if q == repayment_end:
            principal_payment = balloon_principal + quarterly_principal_payment
            remaining_principal = 0
            status = "Paid Off"
        else:
            principal_payment = quarterly_principal_payment

        remaining_principal -= principal_payment
        current_quarterly_rate = np.random.normal(mean_yield, std_yield) / 4

        cumulative_interest += interest_payment
        cumulative_principal += principal_payment
        cumulative_profit = (cumulative_interest + cumulative_principal) - principal

        schedule.append({
            "loan_id": loan_id,
            "loan_type": "real estate loan",
            "status": status,
            "period_originated": origination_quarter,
            "current_period": q,
            "periods_remaining": max(quarters_remaining - 1, 0),
            "annual_interest_rate": current_quarterly_rate * 4,
            "interest_payment": interest_payment,
            "starting_principal": principal,
            "principal_payment": principal_payment,
            "remaining_principal": max(remaining_principal, 0),
            "collateral_value": property_value,
            "default_loss": 0,
            "recovery_amount": 0,
            "cumulative_interest_payments": cumulative_interest,
            "cumulative_principal_payments": cumulative_principal,
            "portfolio_allocation_percent": portfolio_allocation_percent,
        })

        if remaining_principal <= 0:
            break

    return pd.DataFrame(schedule)

"""**Function to simulate the debt schedule for all loans in a portfolio**"""

def portfolio_simulator(loans_df, loan_types):
    """
    Simulates the debt schedule for a portfolio of loans and returns a single DataFrame
    with all loan schedules, sorted by origination quarter and loan ID.

    Parameters:
    - loans_df: A Pandas DataFrame where each row represents a loan with its parameters.
    - loan_types: A dictionary containing loan type details, such as mean_yield and std_yield.

    Returns:
    - A DataFrame containing all loan schedules, sorted by origination quarter and loan ID.
    """
    # Map loan types to their corresponding schedule functions
    schedule_functions = {
        "Senior Secured Loans (BB)": senior_schedule,
        "Middle-Market Direct Lending": direct_lending_schedule,
        "Unitranche Loans": unitranche_schedule,
        "Mezzanine Debt": mezzanine_schedule,
        "Distressed and Special Situations": distressed_schedule,
        "Real Estate and Infrastructure Debt": real_estate_schedule,
    }

    # List to store repayment schedules for all loans
    all_schedules = []

    for _, loan in loans_df.iterrows():
        loan_type = loan["loan_type"]

        # Extract shared parameters
        schedule_params = {
            "loan_id": loan["loan_id"],
            "principal": loan["principal"],
            "initial_yield": loan["interest_rate"],
            "origination_quarter": loan["origination_period"],
            "term_quarters": loan["term_length_quarters"],
            "default_rate": loan["default_rate"],
            "portfolio_allocation_percent": loan.get("portfolio_allocation_percent", 0.1),  # Default to 10%
        }

        # Add loan-type-specific parameters
        if loan_type in ["Senior Secured Loans (BB)", "Unitranche Loans",
                         "Middle-Market Direct Lending", "Real Estate and Infrastructure Debt"]:
            schedule_params.update({
                "mean_yield": loan_types[loan_type]["mean_yield"],
                "std_yield": loan_types[loan_type]["std_yield"],
            })

        if loan_type == "Middle-Market Direct Lending":
            if "interest_type" in direct_lending_schedule.__code__.co_varnames:
                schedule_params["interest_type"] = loan["interest_type"]
            schedule_params["balloon_percent"] = 0.55

        if loan_type == "Real Estate and Infrastructure Debt":
            schedule_params["balloon_rate"] = 0.4

        if loan_type == "Mezzanine Debt":
            schedule_params["cash_to_pik_ratio"] = 0.6

        if loan_type == "Distressed and Special Situations":
            schedule_params["repayment_type"] = loan["repayment_structure"]

        # Call the corresponding schedule function
        try:
            repayment_schedule = schedule_functions[loan_type](**schedule_params)
        except TypeError as e:
            print(f"Error in {loan_type} schedule function: {e}")
            continue

        # Append repayment schedule to the master list
        all_schedules.append(repayment_schedule)

    # Combine all schedules into a single DataFrame
    all_loans_df = pd.concat(all_schedules, ignore_index=True)

    # Sort by origination quarter and loan ID
    all_loans_df.sort_values(by=["current_period", "loan_id"], inplace=True)

    return all_loans_df

"""**Following section gets summary metrics**"""

def portfolio_metrics(portfolio_sim):
    """
    Computes overarching metrics for the entire portfolio.

    Parameters:
    - portfolio_sim: A DataFrame containing the loan schedule for a simulated portfolio.

    Returns:
    - A DataFrame with core portfolio-level metrics.
    """
    # Number of loans
    total_loans = portfolio_sim["loan_id"].nunique()

    # Number of defaults
    total_defaults = (portfolio_sim["status"] == "Defaulted").sum()

    # Default rate
    default_rate = (total_defaults / total_loans) if total_loans > 0 else 0

    # Total interest and principal payments
    total_interest_payments = portfolio_sim["interest_payment"].sum()
    total_principal_payments = portfolio_sim["principal_payment"].sum()

    # Total cash inflows and outflows
    total_cash_inflows = total_interest_payments + total_principal_payments
    total_cash_outflows = portfolio_sim.groupby("loan_id")["starting_principal"].first().sum()

    # Default losses and recovery amounts
    total_default_loss = portfolio_sim["default_loss"].sum()
    total_recovery_amount = portfolio_sim["recovery_amount"].sum()

    # Profit and ROI
    profit = total_cash_inflows - total_cash_outflows
    roi = (profit / total_cash_outflows) if total_cash_outflows > 0 else None

    # IRR Calculation
    cash_flows = (
        portfolio_sim.groupby("current_period")[["interest_payment", "principal_payment"]]
        .sum()
        .sum(axis=1)
        .tolist()
    )
    cash_flows.insert(0, -total_cash_outflows)  # Initial outflow
    irr = npf.irr(cash_flows) if cash_flows else None

    # Return metrics
    return pd.DataFrame([{
        "total_loans": total_loans,
        "total_defaults": total_defaults,
        "default_rate": default_rate,
        "total_interest_payments": total_interest_payments,
        "total_principal_payments": total_principal_payments,
        "total_cash_inflows": total_cash_inflows,
        "total_cash_outflows": total_cash_outflows,
        "total_default_loss": total_default_loss,
        "total_recovery_amount": total_recovery_amount,
        "profit": profit,
        "roi": roi,
        "irr": irr,
    }])

def loan_type_metrics(portfolio_sim):
    """
    Computes basic metrics for each loan type.

    Parameters:
    - portfolio_sim: A DataFrame containing the loan schedule for a simulated portfolio.

    Returns:
    - A DataFrame with metrics for each loan type.
    """
    # Group by loan type
    grouped = portfolio_sim.groupby("loan_type")

    metrics = []
    for loan_type, group in grouped:
        # Core metrics for each loan type
        total_loans = group["loan_id"].nunique()
        total_defaults = (group["status"] == "Defaulted").sum()
        default_rate = total_defaults / total_loans if total_loans > 0 else 0
        total_interest_payments = group["interest_payment"].sum()
        total_principal_payments = group["principal_payment"].sum()
        total_cash_inflows = total_interest_payments + total_principal_payments
        total_cash_outflows = group.groupby("loan_id")["starting_principal"].first().sum()

        # Default loss and recovery metrics
        total_default_loss = group["default_loss"].sum()
        total_recovery_amount = group["recovery_amount"].sum()

        # Profit and ROI
        profit = total_cash_inflows - total_cash_outflows
        roi = profit / total_cash_outflows if total_cash_outflows > 0 else 0

        # Append results
        metrics.append({
            "loan_type": loan_type,
            "total_loans": total_loans,
            "total_defaults": total_defaults,
            "default_rate": default_rate,
            "total_interest_payments": total_interest_payments,
            "total_principal_payments": total_principal_payments,
            "total_cash_inflows": total_cash_inflows,
            "total_cash_outflows": total_cash_outflows,
            "total_default_loss": total_default_loss,
            "total_recovery_amount": total_recovery_amount,
            "profit": profit,
            "roi": roi
        })

    loan_type_df = pd.DataFrame(metrics)

    return loan_type_df

def portfolio_quarterly_metrics(portfolio_sim):
    """
    Computes quarterly metrics.

    Parameters:
    - portfolio_sim: A DataFrame containing the loan schedule for a simulated portfolio.

    Returns:
    - A DataFrame where each row corresponds to a quarter with relevant portfolio metrics.
    """
    cumulative_interest = 0
    cumulative_principal = 0
    cumulative_defaults = 0
    cumulative_realized_cash_flow = 0
    cumulative_default_loss = 0
    cumulative_recovery = 0

    # Group by quarter and calculate metrics
    quarterly_metrics = []
    for quarter, group in portfolio_sim.groupby("current_period"):
        # Quarterly metrics
        active_loans = group[group["status"] == "Active"]["loan_id"].nunique()
        defaults_this_quarter = group[group["status"] == "Defaulted"]["loan_id"].nunique()
        quarterly_interest = group["interest_payment"].sum()
        quarterly_principal = group["principal_payment"].sum()
        quarterly_default_loss = group["default_loss"].sum()
        quarterly_recovery = group["recovery_amount"].sum()
        realized_cash_flow = quarterly_interest + quarterly_principal
        outstanding_principal = group["remaining_principal"].sum()

        # Update cumulative metrics
        cumulative_interest += quarterly_interest
        cumulative_principal += quarterly_principal
        cumulative_realized_cash_flow += realized_cash_flow
        cumulative_defaults += defaults_this_quarter
        cumulative_default_loss += quarterly_default_loss
        cumulative_recovery += quarterly_recovery

        # Calculate profit to date
        cumulative_cash_inflows = cumulative_interest + cumulative_principal
        cumulative_cash_outflows = portfolio_sim.groupby("loan_id")["starting_principal"].first().sum()
        profit_to_date = cumulative_cash_inflows - cumulative_cash_outflows

        # Append metrics
        quarterly_metrics.append({
            "quarter": quarter,
            "active_loans": active_loans,
            "defaults_this_quarter": defaults_this_quarter,
            "cumulative_defaults": cumulative_defaults,
            "quarterly_inflow": realized_cash_flow,
            "cumulative_inflow": cumulative_realized_cash_flow,
            "cumulative_outflow": cumulative_cash_outflows,
            "quarterly_default_loss": quarterly_default_loss,
            "cumulative_default_loss": cumulative_default_loss,
            "quarterly_recovery": quarterly_recovery,
            "cumulative_recovery": cumulative_recovery,
            "outstanding_principal": outstanding_principal,
            "profit_to_date": profit_to_date
        })

    return pd.DataFrame(quarterly_metrics)

"""**Monte Carlo Simulation of 1000 portfolios**"""

def portfolio_sims(n, allocation, portfolio_dist, loan_types, max_percent=0.006, max_quarters=20):
    """
    Runs a Monte Carlo simulation for portfolio performance over n simulations.

    Parameters:
    - n: Number of simulations to run.
    - allocation: Total capital to be allocated.
    - portfolio_dist: Distribution of capital across loan types.
    - loan_types: Characteristics of each loan type.
    - max_percent: Maximum percentage of total allocation for a single loan.
    - max_quarters: Number of quarters over which loans can originate.

    Returns:
    - overall_avg_metrics_df: DataFrame with average overall portfolio metrics.
    - type_avg_metrics_df: DataFrame with average metrics by loan type.
    - quarterly_avg_metrics_df: DataFrame with average metrics by quarter.
    """
    # Initialize storage for metrics
    overall_metrics_list = []
    type_metrics_list = []
    quarterly_metrics_list = []

    for i in tqdm(range(n), desc="Simulating portfolios"):
        # Generate a new loan portfolio
        loans_df = initialize_loans(allocation, portfolio_dist, loan_types, max_percent, max_quarters)

        # Simulate the repayment of that portfolio
        portfolio_sim = portfolio_simulator(loans_df, loan_types)

        # Get aggregate metrics
        overall_metrics = portfolio_metrics(portfolio_sim)
        overall_metrics_list.append(overall_metrics)

        # Get by-type metrics
        type_metrics = loan_type_metrics(portfolio_sim)
        type_metrics["simulation"] = i
        type_metrics_list.append(type_metrics)

        # Get by-quarter metrics
        quarterly_metrics = portfolio_quarterly_metrics(portfolio_sim)
        quarterly_metrics["simulation"] = i
        quarterly_metrics_list.append(quarterly_metrics)

    # Combine all simulation results
    overall_metrics_df = pd.concat(overall_metrics_list, ignore_index=True)
    type_metrics_df = pd.concat(type_metrics_list, ignore_index=True)
    quarterly_metrics_df = pd.concat(quarterly_metrics_list, ignore_index=True)

    # Calculate average metrics across simulations
    overall_avg_metrics_df = overall_metrics_df.mean().to_frame().T
    type_avg_metrics_df = type_metrics_df.groupby("loan_type").mean().reset_index()
    quarterly_avg_metrics_df = quarterly_metrics_df.groupby("quarter").mean().reset_index()

    return overall_avg_metrics_df, type_avg_metrics_df.drop(columns=['simulation']), quarterly_avg_metrics_df.drop(columns=['simulation'])

overall_metrics, type_metrics, period_metrics = portfolio_sims(1000, allocation, portfolio_dist, loan_types)

"""**Storing results as csv files**"""

overall_metrics.to_csv("overall_metrics.csv", index=False)
type_metrics.to_csv("type_metrics.csv", index=False)
period_metrics.to_csv("period_metrics.csv", index=False)

overall_metrics = pd.read_csv("overall_metrics.csv")
type_metrics = pd.read_csv("type_metrics.csv")
period_metrics = pd.read_csv("period_metrics.csv")

"""**Plots to illustrate findings**"""

# Portfolio Distribution by Loan Type
fig, ax = plt.subplots(figsize=(8, 8))

labels = type_metrics['loan_type']
sizes = type_metrics['total_loans']
colors = plt.cm.Paired(range(len(labels)))

ax.pie(
    sizes,
    labels=labels,
    autopct='%1.1f%%',
    startangle=90,
    colors=colors,
    shadow=True,
    textprops={"fontsize": 12},
    wedgeprops={'edgecolor': 'black'}
)

ax.set_title("Portfolio Distribution by Loan Type", fontsize=14)
plt.tight_layout()
plt.show()

# Loan defaults as percent of total loans
total_defaults = overall_metrics["total_defaults"].values[0]
total_loans = overall_metrics["total_loans"].values[0]
non_defaults = total_loans - total_defaults

fig, ax = plt.subplots(figsize=(8, 8))
labels = ["Non-Defaults", "Defaults"]
sizes = [non_defaults, total_defaults]
colors = ["green", "red"]
explode = [0, 0.1]

ax.pie(
    sizes,
    explode=explode,
    labels=labels,
    autopct="%1.1f%%",
    startangle=90,
    colors=colors,
    shadow=True,
    textprops={"fontsize": 12}
)
ax.set_title("Loan Defaults as Proportion of Total Loans", fontsize=14)
plt.show()

# Waterfall plot showing the cash flow steps towards final profit
waterfall_data = pd.DataFrame({
    "label": [
        "Initial Outflow",
        "Total Interest Payments",
        "Total Principal Payments",
        "Profit"
    ],
    "value": [
        -overall_metrics["total_cash_outflows"].iloc[0],
        overall_metrics["total_interest_payments"].iloc[0],
        overall_metrics["total_principal_payments"].iloc[0],
        overall_metrics["profit"].iloc[0],
    ]
})

# Calculate cumulative positions for bars
cumulative = [0]
for value in waterfall_data["value"][:-1]:
    cumulative.append(cumulative[-1] + value)

# Profit starts at 0
starts = cumulative[:-1]
starts.append(0)

heights = waterfall_data["value"]
colors = ['red' if value < 0 else 'green' for value in heights]

# Plot the waterfall chart
fig, ax = plt.subplots(figsize=(12, 6))

for i in range(len(waterfall_data)):
    ax.bar(
        waterfall_data["label"].iloc[i],
        heights.iloc[i],
        bottom=starts[i],
        color=colors[i],
        edgecolor='black',
        width=0.6
    )

    ax.text(
        i,
        starts[i] + heights.iloc[i] / 2,
        f"${heights.iloc[i] / 1e9:.2f}B",
        ha='center',
        va='center',
        fontsize=10,
        color='white' if heights.iloc[i] < 0 else 'black'
    )

# Formatting
ax.set_title("Cash Flow to Profit", fontsize=16, pad=20)
ax.set_ylabel("Amount ($, in billions)", fontsize=12)
ax.axhline(0, color='black', linewidth=0.8, linestyle='--')
plt.xticks(rotation=30, ha='right', fontsize=10)

plt.tight_layout()
plt.show()

type_metrics

# Profit and ROI data for each loan type
fig, ax1 = plt.subplots(figsize=(12, 7))

# Bar plot for profit
profits_in_billion = type_metrics['profit'] / 1e9
bars = ax1.bar(type_metrics['loan_type'], profits_in_billion, color='skyblue', label='Profit ($B)')
ax1.set_ylabel('Profit ($B)', fontsize=12)
ax1.tick_params(axis='y', labelsize=10)
ax1.set_xticklabels(type_metrics['loan_type'], rotation=45, ha='right', fontsize=10)

for bar, profit in zip(bars, profits_in_billion):
    ax1.text(bar.get_x() + bar.get_width() / 2, bar.get_height(), f"{profit:.2f}B",
             ha='center', va='bottom', fontsize=10, color='black')

# Line plot for ROI
ax2 = ax1.twinx()
ax2.plot(type_metrics['loan_type'], type_metrics['roi'], color='darkorange', marker='o', label='ROI (%)')
ax2.set_ylabel('ROI (%)', fontsize=12)
ax2.tick_params(axis='y', labelsize=10)

# Formatting
ax1.legend(loc='upper left', fontsize=10)
ax2.legend(loc='upper right', fontsize=10)

plt.title('Profit and ROI for each Loan Type', fontsize=14, pad=20)
plt.tight_layout()
plt.show()

# Loan Type vs. Cash Flows
fig, ax = plt.subplots(figsize=(12, 7))

# Extract & plot inflows and outflows
cash_inflows_in_billion = type_metrics['total_cash_inflows'] / 1e9  # Convert to billions
cash_outflows_in_billion = -type_metrics['total_cash_outflows'] / 1e9  # Convert to billions (negative for stacking)

bars_inflows = ax.bar(type_metrics['loan_type'], cash_inflows_in_billion, color='green', label='Total Cash Inflows ($B)')
bars_outflows = ax.bar(type_metrics['loan_type'], cash_outflows_in_billion, color='red', label='Total Cash Outflows ($B)')

# Formatting
for bar, value in zip(bars_inflows, cash_inflows_in_billion):
    ax.text(bar.get_x() + bar.get_width() / 2, bar.get_height(), f"{value:.1f}B",
            ha='center', va='bottom', fontsize=10, color='black')
for bar, value in zip(bars_outflows, cash_outflows_in_billion):
    ax.text(bar.get_x() + bar.get_width() / 2, bar.get_height(), f"{value:.1f}B",
            ha='center', va='top', fontsize=10, color='black')

ax.set_ylabel('Cash Flows ($B)', fontsize=12)
ax.set_xlabel('Loan Type', fontsize=12)
ax.set_title('Cash Flows of each Loan Type', fontsize=14, pad=20)
ax.set_xticklabels(type_metrics['loan_type'], rotation=45, ha='right', fontsize=10)
ax.legend(loc='upper left', fontsize=10)

plt.tight_layout()
plt.show()

# Cumulative inflows vs. net principal deployed
fig, ax = plt.subplots(figsize=(12, 6))
period_metrics['year'] = period_metrics['quarter'] / 4

# Cumulative inflows
ax.plot(period_metrics['year'], period_metrics['cumulative_inflow'], label='Cumulative Interest & Principal Payments', color='blue', marker='o')

# Net principal deployed
ax.plot(period_metrics['year'], period_metrics['outstanding_principal'], label='Net Principal Deployed', color='red', marker='o')

# Crossing year
ax.axvline(x=5.9, color='black', linestyle='--', linewidth=1)

# Formatting
ax.set_title('Cumulative Inflows vs. Net Principal Deployed over Time', fontsize=14, pad=20)
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Amount ($)', fontsize=12)
ax.legend(loc='best', fontsize=10)
ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)

plt.tight_layout()
plt.show()

# Profit over time

# Interpolating the exact break-even year
profit_to_date = period_metrics['profit_to_date']
years = period_metrics['year']

break_even_index = np.where(profit_to_date >= 0)[0][0]
if break_even_index > 0:
    x0, x1 = years.iloc[break_even_index - 1], years.iloc[break_even_index]
    y0, y1 = profit_to_date.iloc[break_even_index - 1], profit_to_date.iloc[break_even_index]
    m = (y1 - y0) / (x1 - x0)
    break_even_year = x0 + (0 - y0) / m
else:
    break_even_year = years.iloc[break_even_index]

fig, ax = plt.subplots(figsize=(12, 6))

# Plot profit to date over years
ax.plot(period_metrics['year'], period_metrics['profit_to_date'], label='Profit to Date', color='green', marker='o')

# Formatting
ax.axhline(0, color='black', linestyle='--', linewidth=1)
ax.axvline(x=break_even_year, color='red', linestyle='--', linewidth=1)
ax.text(break_even_year + 0.5, min(profit_to_date) * 0.2, f"Break-even\nYear: {break_even_year:.1f}",
        color='red', ha='left', va='bottom', fontsize=10)

ax.set_title('Profit to Date Over Time', fontsize=14, pad=20)
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Profit ($)', fontsize=12)
ax.legend(loc='best', fontsize=10)
ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)

plt.tight_layout()
plt.show()

# Active loans vs. cumulative defaults
fig, ax = plt.subplots(figsize=(12, 6))

# Plot active loans
bars_active_loans = ax.bar(
    period_metrics['year'], period_metrics['active_loans'],
    label='Active Loans (Excluding Defaults)', color='blue', alpha=0.7, width=0.25, edgecolor='black'
)

# Stack cumulative defaults on top
bars_defaults = ax.bar(
    period_metrics['year'], period_metrics['cumulative_defaults'],
    bottom=period_metrics['active_loans'], label='Cumulative Defaults', color='red', alpha=0.7, width=0.25, edgecolor='black'
)

# Formatting
ax.set_title('Active Loans vs Cumulative Defaults over Time', fontsize=14, pad=20)
ax.set_xlabel('Year', fontsize=12)
ax.set_ylabel('Number of Loans', fontsize=12)
ax.legend(loc='upper right', fontsize=10)
ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.7)

plt.tight_layout()
plt.show()